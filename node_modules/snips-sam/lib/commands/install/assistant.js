"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("../../cli");
const session_1 = require("../../session");
const chalk_1 = require("chalk");
const shelljs = require("shelljs");
const actions_1 = require("./actions");
exports.command = 'assistant';
exports.desc = 'Install an assistant from different locations: console (with or without a project id) or a local file path.';
exports.builder = {
    path: {
        demandOption: false,
        describe: 'Path to local assistant folder, can be a zip',
        type: 'string',
        conflicts: 'id',
        alias: 'p',
    },
    id: {
        demandOption: false,
        describe: 'Your assistant id from the console, format: proj_XXXX',
        type: 'string',
        conflicts: 'path',
        alias: 'i',
    },
    ignore_action_parameters: {
        demandOption: false,
        describe: 'Do not get prompted for action parameters',
        type: 'boolean',
        alias: 'ignore',
        default: false,
    },
};
exports.handler = (argv) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const argsPath = JSON.parse(JSON.stringify(argv)).path;
    const id = JSON.parse(JSON.stringify(argv)).id;
    const ignore = JSON.parse(JSON.stringify(argv)).ignore_action_parameters;
    const ssh = new session_1.SSHService();
    yield ssh.connect()
        .catch(e => {
        cli_1.cli.stream.error(e);
        process.exit();
    });
    let assistantPath;
    if (argsPath !== undefined && argsPath.length > 0) {
        assistantPath = argsPath;
    }
    else {
        if (cli_1.cli.config.user === undefined) {
            cli_1.cli.stream.error(`No user information to connect to the console, you must login first with ${chalk_1.default.blue('sam login')}`);
            process.exit(0);
            return;
        }
        const client = new session_1.ConsoleClient();
        let assistantId;
        if (id !== undefined && id.length > 0) {
            assistantId = id;
        }
        else {
            try {
                cli_1.cli.stream.loading('Fetching assistants');
                assistantId = yield client.assistantList(cli_1.cli.config.user.id)
                    .then((assistants) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                    cli_1.cli.stream.done();
                    const assistantNames = assistants.map(assistant => assistant.title);
                    if (assistantNames.length === 0)
                        throw new Error('No assistants found on your account.');
                    if (assistantNames.length === 1) {
                        cli_1.cli.stream.println(`Found 1 assistant named ${assistants[0].title}`);
                        return assistants[0].id;
                    }
                    return yield cli_1.cli.prompt.promptList('assistant', 'Choose the assistant you wish to install on the device', assistantNames)
                        .then(response => {
                        const assistantSelected = assistants.find(value => value.title === response['assistant']);
                        if (assistantSelected === undefined)
                            throw new Error('No assistant choosen');
                        return assistantSelected.id;
                    });
                }));
            }
            catch (e) {
                cli_1.cli.stream.error(`Error fetching the assistant, reason: ${e.message}`);
                process.exit(0);
                return;
            }
        }
        cli_1.cli.stream.println('Downloading assistant');
        const assistantPathVoid = yield client.downloadAssistant(assistantId, steps => {
            cli_1.cli.stream.done();
            cli_1.cli.stream.loading(steps);
        })
            .catch(e => cli_1.cli.stream.error(e));
        if (assistantPathVoid) {
            assistantPath = assistantPathVoid;
        }
        else {
            process.exit(0);
            return;
        }
    }
    cli_1.cli.stream.loading(`Deploying assistant to ${ssh.credentials.hostname}...`);
    yield ssh.installAssistant(assistantPath)
        .then(_ => {
        if (argsPath !== undefined && argsPath.length > 0)
            return;
        shelljs.rm('-rf', assistantPath);
    })
        .then(_ => cli_1.cli.stream.success())
        .catch(e => {
        cli_1.cli.stream.error(`Unable to install the assistant: ${e.message}`);
        ssh.disconnect();
        process.exit();
    });
    try {
        const skillSetup = new actions_1.SkillSetup(ssh, ignore);
        yield skillSetup.run();
        yield ssh.relaunchServices().catch(_ => { });
        const assistant = yield ssh.getInstalledAssistant();
        if (assistant !== undefined) {
            cli_1.cli.stream.success(`Snips assistant is now running. Say ${chalk_1.default.blue(assistant.hotword)} to start!`);
        }
        else {
            cli_1.cli.stream.success('Snips assistant is now running');
        }
        cli_1.cli.stream.hint(`Run ${chalk_1.default.blue('sam watch')} to see the logs`);
    }
    catch (error) {
        cli_1.cli.stream.error(error);
    }
    ssh.disconnect();
    process.exit();
});
//# sourceMappingURL=assistant.js.map