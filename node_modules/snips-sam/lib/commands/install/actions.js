"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("../../cli");
const session_1 = require("../../session");
const chalk_1 = require("chalk");
const shelljs = require("shelljs");
const hassConfiguration_1 = require("../../models/hassConfiguration");
const utils_1 = require("../../utils");
const ini = require("ini");
exports.command = 'actions';
exports.desc = 'Install actions present on the device';
exports.aliases = 'skills';
exports.builder = {
    git: {
        demandOption: false,
        describe: 'Install an action from a git repository',
        type: 'string',
        alias: 'g',
    },
    branch: {
        demandOption: false,
        describe: 'Specify the git branch you want to use',
        type: 'string',
        alias: 'b',
    },
    ignore_action_parameters: {
        demandOption: false,
        describe: 'Do not get prompted for action parameters',
        type: 'boolean',
        alias: 'ignore',
        default: false,
    },
};
exports.handler = (argv) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const git = JSON.parse(JSON.stringify(argv)).git;
    const branch = JSON.parse(JSON.stringify(argv)).branch;
    const ignore = JSON.parse(JSON.stringify(argv)).ignore_action_parameters;
    const ssh = new session_1.SSHService();
    yield ssh.connect()
        .catch(e => {
        cli_1.cli.stream.error(e);
        process.exit();
    });
    try {
        const skillSetup = new SkillSetup(ssh, ignore, git, branch);
        yield skillSetup.run();
        const assistant = yield ssh.getInstalledAssistant();
        if (assistant !== undefined) {
            cli_1.cli.stream.success(`Snips assistant is now running. Say ${chalk_1.default.blue(assistant.hotword)} to start!`);
        }
        else {
            cli_1.cli.stream.success('Snips assistant is now running');
        }
    }
    catch (error) {
        cli_1.cli.stream.error(error);
    }
    ssh.disconnect();
    process.exit();
});
class SkillSetup {
    constructor(ssh, ignore, git, branch) {
        this.ssh = ssh;
        this.ignore = ignore;
        this.git = git;
        this.branch = branch;
        this.hassSnippets = new Map();
        this.hassCfgPath = '/home/homeassistant/.homeassistant/';
    }
    run() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.singleGitInstall = (this.git !== undefined && this.git.length > 0);
            if (!this.singleGitInstall)
                cli_1.cli.stream.println(chalk_1.default.green('Checking for actions'));
            const snipsfile = yield this.ssh.getAssistantSnipsfile()
                .catch(e => cli_1.cli.stream.error(`Error reading the Snipsfile for skills, reason: ${e.message}`));
            this.snippets = yield this.ssh.getSnippets().catch(_ => { });
            if (!this.singleGitInstall) {
                this.snippets && this.snippets.forEach((skill, key) => {
                    if (skill.type.includes('python')) {
                        this.hasPythonSkill = true;
                        let snippetPlural = 'snippet:';
                        if (skill.snippets.length > 1)
                            snippetPlural = 'snippets:';
                        cli_1.cli.stream.println(`Python skill ${key} has ${skill.snippets.length} ${snippetPlural}`);
                        skill.snippets.forEach(snippet => cli_1.cli.stream.println(`\t${snippet}`));
                    }
                    if (skill.type.includes('homeassistant')) {
                        this.hasHassSkill = true;
                        this.hassSnippets.set(key, skill.snippets);
                        let snippetPlural = ' snippet:';
                        if (skill.snippets.length > 1)
                            snippetPlural = ' snippets:';
                        cli_1.cli.stream.println(`Home Assistant skill ${key} has ${skill.snippets.length} ${snippetPlural}`);
                        skill.snippets.forEach(snippet => cli_1.cli.stream.println(`\t${snippet}`));
                    }
                    if (skill.type.includes('javascript')) {
                        this.hasJsSkill = true;
                        let snippetPlural = 'snippet:';
                        if (skill.snippets.length > 1)
                            snippetPlural = 'snippets:';
                        cli_1.cli.stream.println(`Javascript skill ${key} has ${skill.snippets.length} ${snippetPlural}`);
                        skill.snippets.forEach(snippet => cli_1.cli.stream.println(`\t${snippet}`));
                    }
                });
            }
            this.hasGitSkill = snipsfile !== undefined && snipsfile.skills.length > 0;
            try {
                const templateInstalled = yield this.ssh.dpkgCheckIfPackageIsInstalled(session_1.SnipsServices.template);
                if (!templateInstalled) {
                    cli_1.cli.stream.loading(`Installing ${session_1.SnipsServices.template} and ${session_1.SnipsServices.skillServer}`);
                    yield this.ssh.aptGetY([session_1.SnipsServices.template, session_1.SnipsServices.skillServer], _ => { });
                    cli_1.cli.stream.success();
                    yield this.ssh.addCurrentUserToSnipsSkillsAdminGroup().catch(_ => { });
                }
            }
            catch (e) {
            }
            yield this.ssh.stopService(session_1.SnipsServices.skillServer);
            if (this.hasGitSkill || this.singleGitInstall) {
                if (!(yield this.ssh.checkCommandExists('git'))) {
                    cli_1.cli.stream.loading('Installing git package');
                    yield this.ssh.aptGetY(['git'], _ => { });
                    cli_1.cli.stream.success();
                }
                if (snipsfile !== undefined && snipsfile.skills.length > 0 && !this.singleGitInstall) {
                    for (const skill of snipsfile.skills) {
                        if (skill.url) {
                            cli_1.cli.stream.println(`Cloning skill ${skill.name} from url: ${skill.url}`);
                            yield this.ssh.gitClone(skill.url, undefined, output => cli_1.cli.stream.println(output), permissionError => cli_1.cli.stream.warning(permissionError));
                        }
                    }
                }
                if (this.git !== undefined && this.git.length > 0) {
                    cli_1.cli.stream.println(`Cloning skill from url: ${this.git}`);
                    yield this.ssh.gitClone(this.git, this.branch, output => cli_1.cli.stream.println(output), permissionError => cli_1.cli.stream.warning(permissionError));
                }
            }
            if (this.snippets !== undefined && !this.singleGitInstall) {
                cli_1.cli.stream.println(chalk_1.default.green('Generating actions based on the snippets, copying the actions in /var/lib/snips/skills'));
                yield this.ssh.snipsTemplateRender(l => cli_1.cli.stream.print(l))
                    .catch(e => cli_1.cli.stream.error(`Unable to generate the python action, reason: ${e.message}`));
                if (this.hasPythonSkill) {
                    cli_1.cli.stream.println(chalk_1.default.green('\nSetting up Python actions'));
                }
                if (this.hasJsSkill) {
                    cli_1.cli.stream.println(chalk_1.default.green('\nSetting up Javascript actions'));
                }
                if (this.hasHassSkill) {
                    cli_1.cli.stream.println(chalk_1.default.green('\nSetting up Home Assistant actions'));
                    yield this.setupHomeAssistantSkill()
                        .then(_ => cli_1.cli.stream.loading('Relaunching Home Assistant'))
                        .then(_ => this.ssh.restartHomeAssistant())
                        .then(_ => cli_1.cli.stream.success())
                        .catch(e => cli_1.cli.stream.error(`Unable to install Home Assistant action, reason: ${e.message}`));
                }
            }
            const generatedSkills = yield this.ssh.getGeneratedSkills().catch(_ => _);
            try {
                if (generatedSkills !== undefined && generatedSkills.length > 0) {
                    yield this.ssh.checkCommandExists('virtualenv')
                        .then(isVirtualEnvInstalled => {
                        if (!isVirtualEnvInstalled) {
                            cli_1.cli.stream.loading('Installing pip and virtualenv. This could take a while.');
                            return this.ssh.installPythonAndPip(_ => { })
                                .then(_ => cli_1.cli.stream.success());
                        }
                        return;
                    })
                        .catch(e => cli_1.cli.stream.error(`Unable to install python-pip & virtualenv, reason: ${e.message}`));
                }
            }
            catch (error) {
                cli_1.cli.stream.error(error.message);
            }
            if ((this.hasPythonSkill || this.hasGitSkill || this.singleGitInstall || this.hasJsSkill)
                && (generatedSkills !== undefined && generatedSkills.length > 0)) {
                try {
                    yield this.runSetupSH(generatedSkills);
                    cli_1.cli.stream.println(chalk_1.default.green('\nChecking actions for end-user parameters'));
                    if (!this.ignore) {
                        yield this.promptForParameters(generatedSkills);
                    }
                    cli_1.cli.stream.println('Relaunching snips-skill-server');
                    yield this.ssh.relaunchService(session_1.SnipsServices.skillServer);
                }
                catch (error) {
                    cli_1.cli.stream.error(error.message);
                }
            }
        });
    }
    runSetupSH(generatedSkills) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (generatedSkills) {
                for (const key of generatedSkills) {
                    try {
                        cli_1.cli.stream.println(chalk_1.default.green(`Running setup.sh for ${key}`));
                        const result = yield this.ssh.runSkillSetupSH(key);
                        cli_1.cli.stream.println(`setup.sh output:\n${result}`);
                    }
                    catch (error) {
                        cli_1.cli.stream.error(`Error setting up ${key}, one or more actions might not be able to run. Reason :\n${error.message}`);
                    }
                }
            }
        });
    }
    updateConfigForSection(section, folder, skillName = folder) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rawConfig = yield this.ssh.getSkillConfig(folder);
            const config = rawConfig && ini.parse(rawConfig);
            const configPath = `/var/lib/snips/skills/${folder}/config.ini`;
            if (config && config[section] && Object.keys(config[section]).length > 0) {
                cli_1.cli.stream.hint(`Action ${skillName} contains ${section} parameters that needs to be configured`);
                const lines = Object.entries(config[section]);
                const answers = yield cli_1.cli.prompt.promptQuestions(lines.map(([key, val]) => ({
                    name: key,
                    default: val,
                    message: `Please enter a value for the parameter [${key}]`,
                })));
                Object.entries(answers).forEach(([key, value]) => {
                    config[section][key] = value;
                });
                cli_1.cli.stream.hint(`You can change these values later by editing the file located at ${configPath}`);
                const newConfig = ini.stringify(config);
                yield this.ssh.updateSkillConfig(newConfig, folder);
            }
        });
    }
    promptForParameters(generatedSkills) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (generatedSkills) {
                for (const key of generatedSkills) {
                    yield this.updateConfigForSection('global', key);
                    yield this.updateConfigForSection('secret', key);
                }
            }
        });
    }
    setupHomeAssistantSkill() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.ssh.fileExists(`${this.hassCfgPath}configuration.yaml`)
                .then(exists => {
                if (!exists)
                    return this.askUserForCustomHassInstallConfigurationPath();
                cli_1.cli.stream.success('Found Home Assistant configuration.yaml');
                return this.hassCfgPath;
            })
                .then(cfgFilePath => {
                if (cfgFilePath === undefined)
                    return this.installHass();
                return cfgFilePath;
            })
                .then(cfgFilePath => this.hassCfgPath = cfgFilePath.replace(/\/?$/, '/'))
                .then(_ => cli_1.cli.stream.println('Moving generated actions to Hass python_script folder'))
                .then(_ => this.ssh.moveSkillsToHomeAssistantFolder(`${this.hassCfgPath}python_scripts`, Array.from(this.hassSnippets.keys())))
                .then(_ => cli_1.cli.stream.println('Backing up your last Hass configuration'))
                .then(_ => this.ssh.backupHassConfiguration(this.hassCfgPath))
                .then(_ => this.ssh.getFile(`${this.hassCfgPath}configuration.yaml`))
                .then(file => {
                const parsedYamlFile = hassConfiguration_1.HassConfiguration.parse(file);
                if (parsedYamlFile === undefined)
                    throw new Error('Error parsing the Home Assistant configuration');
                return parsedYamlFile;
            })
                .then(hassCfgFile => {
                cli_1.cli.stream.println('Creating new Hass configuration');
                return this.ssh.getInstalledAssistant()
                    .then(assistantFile => {
                    return hassConfiguration_1.HassConfiguration.generateSnipsConfiguration(hassCfgFile, assistantFile, this.hassSnippets);
                });
            })
                .then(newYamlFilePath => {
                return this.ssh.putFile(newYamlFilePath, '/tmp/configuration.yaml')
                    .then(_ => shelljs.rm(newYamlFilePath))
                    .then(_ => this.ssh.run(`sudo mv /tmp/configuration.yaml ${this.hassCfgPath}`));
            });
        });
    }
    askUserForCustomHassInstallConfigurationPath() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return cli_1.cli.prompt.promptQuestions([
                {
                    name: 'isInstalled',
                    type: 'confirm',
                    message: 'Is Home Assistant already installed on this device?',
                },
            ])
                .then(isHassInstalled => {
                if (isHassInstalled['isInstalled']) {
                    let hassCfgFound = false;
                    return cli_1.cli.prompt.promptQuestions([
                        {
                            name: 'hassCfgPath',
                            type: 'input',
                            message: 'Enter the path to Home Assistant configuration file.',
                            validate: (value) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                                if (value.length === 0)
                                    return "Path can't be blank";
                                const pathWithSlash = value.replace(/\/?$/, '/');
                                hassCfgFound = yield this.ssh.fileExists(`${pathWithSlash}configuration.yaml`);
                                if (!hassCfgFound)
                                    return `Didn't find ${pathWithSlash}configuration.yaml on the device`;
                                return true;
                            }),
                        },
                    ])
                        .then(cfgPathResponse => cfgPathResponse['hassCfgPath']);
                }
                return undefined;
            });
        });
    }
    installHass() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const hassInstallation = yield cli_1.cli.prompt.promptQuestions([
                {
                    name: 'installHass',
                    type: 'confirm',
                    message: 'You need to install Home Assistant to continue, proceed?',
                },
            ]);
            if (!hassInstallation['installHass']) {
                cli_1.cli.stream.println('Quitting');
                cli_1.cli.stream.hint(`You can install Home Assistant by running ${chalk_1.default.blue('sam hass install')}`);
                throw new Error("Hass isn't installed, aborting");
            }
            cli_1.cli.stream.println('Installing Home Assistant, this can take a while');
            return yield this.ssh.installHomeAssistant(_ => { }, stepTitle => {
                cli_1.cli.stream.println(chalk_1.default.green(stepTitle));
            })
                .then((_) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                let loadingText = 'Waiting for Home Assistant initial setup. This could take a while.';
                cli_1.cli.stream.loading(loadingText);
                let homeAssistantConfigurationDetected = false;
                while (!homeAssistantConfigurationDetected) {
                    yield utils_1.timeout(5000);
                    homeAssistantConfigurationDetected = yield this.ssh.fileExists('/home/homeassistant/.homeassistant/configuration.yaml');
                    loadingText += ' . ';
                    cli_1.cli.stream.loading(loadingText);
                }
                cli_1.cli.stream.success();
                return 'success';
            }))
                .then(_ => this.hassCfgPath);
        });
    }
}
exports.SkillSetup = SkillSetup;
//# sourceMappingURL=actions.js.map