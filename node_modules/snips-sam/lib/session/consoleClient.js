"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const utils_1 = require("../utils");
const wretch_1 = require("wretch");
const cli_1 = require("../cli");
const models_1 = require("../models");
const path = require('path');
const fs = require('fs');
const uuidv4 = require('uuid/v4');
class ConsoleClient {
    constructor() {
        this.wretch = wretch_1.default()
            .url('https://external-gateway.snips.ai')
            .polyfills({
            fetch: require('node-fetch'),
            FormData: require('form-data'),
            URLSearchParams: require('url').URLSearchParams,
        })
            .catcher(401, _ => {
            throw new Error('You need to login again');
        });
        if (cli_1.cli.config.consoleToken && cli_1.cli.config.consoleToken.token !== undefined) {
            this.wretch.defaults({ headers: { Authorization: cli_1.cli.config.consoleToken.token } });
        }
    }
    login(email, password) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.wretch
                .url('/v1/user/auth')
                .json({ email, password })
                .post()
                .res()
                .then(response => {
                const token = response.headers.get('authorization');
                if (token === null)
                    throw new Error('Error fetching JWT token');
                return response.json()
                    .then(json => {
                    const user = new models_1.User(json['user']);
                    return { user, token };
                });
            })
                .then(tuple => {
                return this.accessToken(tuple.user.id, tuple.token)
                    .then(tokenObject => {
                    const consoleCredentials = new models_1.ConsoleToken(tokenObject);
                    consoleCredentials.token = `JWT ${consoleCredentials.token}`;
                    this.wretch.defaults({ headers: { Authorization: consoleCredentials.token } });
                    return { user: tuple.user, token: consoleCredentials };
                });
            })
                .then(tuple => {
                const user = { id: tuple.user.id };
                cli_1.cli.config.user = user;
                cli_1.cli.config.consoleToken = tuple.token;
                return cli_1.cli.config.save().then(_ => user);
            });
        });
    }
    logout(userId, alias) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.wretch
                .url(`/v1/user/${userId}/accesstoken/${alias}`)
                .delete()
                .error(204, () => { })
                .res()
                .then(_ => {
                cli_1.cli.config.user = undefined;
                cli_1.cli.config.consoleToken = undefined;
                return cli_1.cli.config.save();
            });
        });
    }
    accessToken(userId, jwtToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const alias = (`sam-${uuidv4()}`).replace(/-/g, '').substring(0, 29);
            return this.wretch
                .url(`/v1/user/${userId}/accesstoken`)
                .auth(jwtToken)
                .json({ alias })
                .post()
                .json(json => new models_1.ConsoleToken(json['token']));
        });
    }
    assistantList(userId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.wretch
                .url('/v3/assistant')
                .query({ userId })
                .get()
                .json(json => {
                const assistants = json['assistants'].map(assistant => models_1.Assistant.fromJSON(assistant));
                if (assistants === null || assistants === undefined)
                    return [];
                return assistants;
            });
        });
    }
    trainAssistant(assistantId, trainingType) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.wretch
                .url(`/v2/training/assistant/${assistantId}`)
                .json({ trainingType })
                .post()
                .error(304, () => { })
                .error(409, () => { })
                .res();
        });
    }
    trainingStatus(assistantId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.wretch
                .url(`/v2/training/assistant/${assistantId}`)
                .get()
                .error(304, () => { })
                .error(409, () => { })
                .json(json => new models_1.TrainingStatusResponse(json));
        });
    }
    handleTraining(assistantId, steps) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let trainingFinished = false;
            while (!trainingFinished) {
                const trainingStatus = yield this.trainingStatus(assistantId);
                if (!trainingStatus.nluStatus.needTraining && !trainingStatus.nluStatus.inProgress &&
                    !trainingStatus.asrStatus.needTraining && !trainingStatus.asrStatus.inProgress) {
                    trainingFinished = true;
                    break;
                }
                else if (trainingStatus.nluStatus.inProgress || trainingStatus.asrStatus.inProgress) {
                }
                else if (trainingStatus.nluStatus.needTraining &&
                    !trainingStatus.nluStatus.inProgress &&
                    !trainingStatus.asrStatus.inProgress) {
                    steps('NLU training');
                    yield this.trainAssistant(assistantId, models_1.TrainingType.NLU);
                }
                else if (!trainingStatus.nluStatus.inProgress &&
                    trainingStatus.asrStatus.needTraining &&
                    !trainingStatus.asrStatus.inProgress) {
                    steps('ASR training');
                    yield this.trainAssistant(assistantId, models_1.TrainingType.ASR);
                }
                yield utils_1.timeout(5000);
            }
        });
    }
    downloadAssistant(assistantId, steps) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.handleTraining(assistantId, steps)
                .then(_ => steps('Downloading assistant'))
                .then(_ => this.wretch
                .url(`/v3/assistant/${assistantId}/download`)
                .get()
                .res(response => {
                const filePath = path.join(utils_1.samConfigDirectory, 'assistant.zip');
                const file = fs.createWriteStream(filePath);
                return new Promise((resolve, reject) => {
                    if (response.body) {
                        response.body['pipe'](file)
                            .on('finish', () => {
                            resolve(filePath);
                        })
                            .on('error', () => {
                            reject('Error downloading assistant');
                        });
                    }
                    else {
                        reject('Response has no body');
                    }
                });
            }));
        });
    }
}
exports.ConsoleClient = ConsoleClient;
//# sourceMappingURL=consoleClient.js.map