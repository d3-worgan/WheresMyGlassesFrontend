import { timeout, samConfigDirectory } from '../utils'
import wretch from 'wretch'
import { Wretcher } from 'wretch/dist/wretcher'
import { cli } from '../cli'
import { User, ConsoleToken, Assistant, TrainingType, TrainingStatusResponse } from '../models'

const path = require('path')
const fs = require('fs')
const uuidv4 = require('uuid/v4')

export class ConsoleClient {
    private wretch: Wretcher

    constructor() {
        // const httpsProxyAgent = require('https-proxy-agent')
        this.wretch = wretch()
        .url('https://external-gateway.snips.ai')
        // .options({ agent: httpsProxyAgent('http://127.0.0.1:8888') })
        .polyfills({
            fetch: require('node-fetch'),
            FormData: require('form-data'),
            URLSearchParams: require('url').URLSearchParams,
        })
        .catcher(401, _ => {
            throw new Error('You need to login again')
        })

        if (cli.config.consoleToken && cli.config.consoleToken.token !== undefined) {
            this.wretch.defaults({ headers: { Authorization: cli.config.consoleToken.token } })
        }
    }

    public async login(email: string, password: string): Promise<User> {
        return this.wretch
        .url('/v1/user/auth')
        .json({ email, password })
        .post()
        .res()
        .then(response => {
            const token = response.headers.get('authorization')
            if (token === null) throw new Error('Error fetching JWT token')
            return response.json()
            .then(json => {
                const user: User = new User(json['user'])
                return { user, token }
            })
        })
        .then(tuple => {
            return this.accessToken(tuple.user.id, tuple.token)
            .then(tokenObject => {
                const consoleCredentials = new ConsoleToken(tokenObject)
                consoleCredentials.token = `JWT ${consoleCredentials.token}`
                this.wretch.defaults({ headers: { Authorization: consoleCredentials.token } })
                return { user: tuple.user, token: consoleCredentials }
            })
        })
        .then(tuple => {
            const user: User = { id: tuple.user.id }
            cli.config.user = user
            cli.config.consoleToken = tuple.token
            return cli.config.save().then(_ => user)
        })
    }

    public async logout(userId: string, alias: string) {
        return this.wretch
        .url(`/v1/user/${userId}/accesstoken/${alias}`)
        .delete()
        .error(204, () => {})
        .res()
        .then(_ => {
            cli.config.user = undefined
            cli.config.consoleToken = undefined
            return cli.config.save()
        })
    }

    public async accessToken(userId: string, jwtToken: string): Promise<ConsoleToken> {
        const alias = (`sam-${uuidv4()}`).replace(/-/g, '').substring(0, 29)
        return this.wretch
        .url(`/v1/user/${userId}/accesstoken`)
        .auth(jwtToken)
        .json({ alias })
        .post()
        .json(json => new ConsoleToken(json['token']))
    }

    public async assistantList(userId: string): Promise<Assistant[]> {
        return this.wretch
        .url('/v3/assistant')
        .query({ userId })
        .get()
        .json(json => {
            const assistants: Assistant[] = json['assistants'].map(assistant => Assistant.fromJSON(assistant))
            if (assistants === null || assistants === undefined) return []
            return assistants
        })
    }

    public async trainAssistant(assistantId: string, trainingType: TrainingType): Promise<void> {
        return this.wretch
        .url(`/v2/training/assistant/${assistantId}`)
        .json({ trainingType })
        .post()
        .error(304, () => {})
        .error(409, () => {})
        .res()
    }

    public async trainingStatus(assistantId: string): Promise<TrainingStatusResponse> {
        return this.wretch
        .url(`/v2/training/assistant/${assistantId}`)
        .get()
        .error(304, () => {})
        .error(409, () => {})
        .json(json => new TrainingStatusResponse(json))
    }

    async handleTraining(assistantId: string, steps: (string) => void): Promise<void> {
        let trainingFinished = false

        while (!trainingFinished) {
            const trainingStatus = await this.trainingStatus(assistantId)

            if (!trainingStatus.nluStatus.needTraining && !trainingStatus.nluStatus.inProgress &&
                !trainingStatus.asrStatus.needTraining && !trainingStatus.asrStatus.inProgress) {
                trainingFinished = true
                break
            } else if (trainingStatus.nluStatus.inProgress || trainingStatus.asrStatus.inProgress) {
                // nothing to do
            } else if (trainingStatus.nluStatus.needTraining &&
                !trainingStatus.nluStatus.inProgress &&
                !trainingStatus.asrStatus.inProgress) {
                steps('NLU training')
                await this.trainAssistant(assistantId, TrainingType.NLU)
            } else if (!trainingStatus.nluStatus.inProgress &&
                trainingStatus.asrStatus.needTraining &&
                !trainingStatus.asrStatus.inProgress) {
                steps('ASR training')
                await this.trainAssistant(assistantId, TrainingType.ASR)
            }
            await timeout(5000)
        }
    }

    public async downloadAssistant(assistantId: string, steps: (string) => void): Promise<string> {
        return await this.handleTraining(assistantId, steps)
        .then(_ => steps('Downloading assistant'))
        .then(_ =>
            this.wretch
            .url(`/v3/assistant/${assistantId}/download`)
            .get()
            .res(response => {
                const filePath = path.join(samConfigDirectory, 'assistant.zip')
                const file: NodeJS.WritableStream = fs.createWriteStream(filePath)
                return new Promise<string>((resolve, reject) => {
                    if (response.body) {
                        response.body['pipe'](file)
                        .on('finish', () => {
                            resolve(filePath)
                        })
                        .on('error', () => {
                            reject('Error downloading assistant')
                        })
                    } else {
                        reject('Response has no body')
                    }
                })
            }),
        )
    }
}
