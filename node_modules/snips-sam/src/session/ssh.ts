import fsExtra = require('fs-extra')
import { DeviceCredentials, AssistantFile, Snipsfile } from '../models'
import { AudioDevice, newError, timeout } from '../utils'
import { Assets } from '../assets'
import { cli } from '../cli'
import * as nodeSsh from 'node-ssh'
import * as shelljs from 'shelljs'
import os = require('os')
import path = require('path')
import fs = require('fs')

export const snipsRemoteAuthorizedKeysFilename = '~/.ssh/authorized_keys'

const snipsRSAKeyName = 'id_rsa_snips'
const snipsRSAKeyFilePath = path.join(os.homedir(), '.ssh', snipsRSAKeyName)

export enum SnipsServices {
    analytics = 'snips-analytics',
    asr = 'snips-asr',
    audioServer = 'snips-audio-server',
    dialogue = 'snips-dialogue',
    hotword = 'snips-hotword',
    nlu = 'snips-nlu',
    skillServer = 'snips-skill-server',
    template = 'snips-template',
    tts = 'snips-tts',
    watch = 'snips-watch',
}

export const availableSnipsServices: string[] = [
    SnipsServices.asr,
    SnipsServices.audioServer,
    SnipsServices.dialogue,
    SnipsServices.hotword,
    SnipsServices.nlu,
    SnipsServices.skillServer,
    SnipsServices.tts,
]

export class SSHService {

    ssh: any
    credentials: DeviceCredentials

    constructor() {
        this.ssh = new nodeSsh()
    }

    public async connect(): Promise<string> {
        const credentials: DeviceCredentials | undefined = cli.config.credentials
        if (credentials === undefined ||
            credentials.hostname === null) {
            throw new Error('No credentials found')
        }

        return this.connectInternal(credentials)
        .catch(e => {
            this.disconnect()
            throw newError(`Connection failed, is your device turned on? \nError: ${e.message}`)
        })
    }

    public async retryConnect(tick: (numberOfRetries: number) => void, limit = 5): Promise<boolean> {
        let isConnected = false
        let numberOfRetries = 0
        while (isConnected === false && limit > numberOfRetries) {
            await timeout(5000)
            tick(numberOfRetries)
            await this.connect()
            .then(_ =>  isConnected = true)
            .catch(_ => {})
            numberOfRetries += 1
        }
        return isConnected
    }

    public async newConnection(credentials: DeviceCredentials, password: string, onConnected: () => void, onSSHCopyId: () => void, onCredentialsSaved: () => void, onSSHKeygenExeNotFound: (path: string) => Promise<string>): Promise<void> {
        await this.connectInternal(credentials, password)
        .then(_ => onConnected())
        .catch(e => {
            throw new Error(`Error connecting to ${credentials.hostname}: ${e.message}`)
        })

        await this.sshCopyId(onSSHKeygenExeNotFound)
        .then(_ => onSSHCopyId())
        .catch(e => {
            this.disconnect()
            throw new Error(`Failed to copy SSH public key: ${e.message}`)
        })

        cli.config.credentials = this.credentials
        await cli.config.save()
        .then(_ => onCredentialsSaved())
        .catch(e => {
            this.disconnect()
            throw new Error(`Failed to save credentials: ${e.message}`)
        })
    }

    private async connectInternal (credentials: DeviceCredentials, password?: string): Promise<any> {
        this.credentials = credentials

        if (password != null) {
            return this.ssh.connect({
                password,
                host: this.credentials.hostname,
                username: this.credentials.username,

            })
        }
        return this.ssh.connect({
            host: this.credentials.hostname,
            username: this.credentials.username,
            privateKey: snipsRSAKeyFilePath,
        })
    }

    public async disconnect(): Promise<void> {
        await this.ssh.dispose()
    }

    public async reboot(): Promise<void> {
        this.ssh.exec('sudo reboot')
    }

    public writeFile(contents: string, remotePath: string) {
        const tmpDir = path.join(os.tmpdir(), 'sam')
        if (!fs.existsSync(tmpDir)) {
            fs.mkdirSync(tmpDir)
        }
        const tmpPath = path.join(tmpDir, path.basename(remotePath))
        fs.writeFileSync(tmpPath, contents, { encoding: 'utf8' })
        return this.ssh.putFile(tmpPath, remotePath)
    }

    public async writeFileAsSnipsSKills(contents: string, remotePath: string) {
        const tmpRemotePath = `/tmp/${path.basename(remotePath)}`
        await this.writeFile(contents, tmpRemotePath)
        return this.ssh.exec(`sudo -u _snips-skills bash -c 'cp "${tmpRemotePath}" "${remotePath}"'`)
        .then(_ => this.removeFile(tmpRemotePath))
    }

    public async writeFileAsRoot(contents: string, remotePath: string) {
        const tmpRemotePath = `/tmp/${path.basename(remotePath)}`
        await this.writeFile(contents, tmpRemotePath)
        return this.ssh.exec(`cat "${tmpRemotePath}" | sudo tee "${remotePath}" > /dev/null && rm "${tmpRemotePath}"`)
    }

    public async isAssistantInstalled(): Promise<boolean> {
        return this.ssh.exec('if [ -d /usr/share/snips/assistant ]; then echo 1; else echo 0; fi')
        .then(result => result === '1')
    }

    public async getInstalledAssistant(): Promise<AssistantFile> {
        const assistantFilename = '/usr/share/snips/assistant/assistant.json'
        return this.ssh.exec(`if [ -f ${assistantFilename} ]; then cat ${assistantFilename}; else echo ""; fi`)
        .then(assistantJSON => {
            if (assistantJSON === '') throw new Error('No assistant installed')
            return new AssistantFile(assistantJSON)
        })
    }

    public async getOSVersion(): Promise<string> {
        return this.ssh.exec('cat /etc/os-release')
        .then(success => {
            const osVersion = success.split('\n')[0].replace('PRETTY_NAME="', '').replace('"', '')
            if (osVersion === null || osVersion.length === 0) {
                return 'Unknown'
            }
            return osVersion
        })
        .catch(_ => {
            return 'Unknown'
        })
    }

    public async installSnipsPlatformDemo(listener: (output: string) => void): Promise<string> {
        return this.aptGetY(['snips-platform-demo'], listener)
    }

    public async aptGetY(packageNames: string[], listener: (output: string) => void): Promise<string> {
        // TODO Handle apt get error codes
        return this.sshCommandLog(`sudo apt-get update; sudo apt-get install -y ${packageNames.join(' ')}`, listener)
    }

    public async isNetcatInstalled(): Promise<boolean> {
        return this.ssh.exec('if [ -x "$(command -v nc)" ]; then echo 1; else echo 0; fi')
        .then(result => result === '1')
        .then(result => {
            if (!result) {
                return this.dpkgCheckIfPackageIsInstalled('netcat')
            }
            return result
        })
    }

    public async speakerTest(): Promise<string> {
        return this.ssh.exec('sudo speaker-test -c2 -twav')
    }

    public async stopSpeakerTest(): Promise<string> {
        return this.ssh.exec('pkill speaker-test')
    }

    public async setHostname(newHostname: string): Promise<string> {
        const oldHostname = await this.ssh.exec('cat /etc/hostname')
        .catch(_ => {
            throw new Error('You device hostname was not readable')
        })

        return this.ssh.exec(`sudo sed -i "s/${oldHostname}/${newHostname}/g" /etc/hosts; sudo sed -i "s/${oldHostname}/${newHostname}/g" /etc/hostname; sudo reboot`)
        .then(_ => {
            this.credentials.hostname = `${newHostname}.local`
            cli.config.credentials = this.credentials
            return cli.config.save()
        })
        .catch(_ => {
            this.credentials.hostname = `${newHostname}.local`
            cli.config.credentials = this.credentials
            return cli.config.save()
        })
    }

    public static async fetchBootHostname(ips: string[]): Promise<{ ip: string, hostname: string, snipsHostname: string }[]> {
        return await Promise.all(
            ips.map(async ip => {
                const client = new nodeSsh()
                const hostnames = await client.connect({
                    host: ip,
                    username: 'pi',
                    password: 'raspberry',
                })
                .then(async _ => {
                    const snipsHostname = await client.exec('if [ -f /boot/alias ]; then echo 1; else echo 0; fi')
                    .then(result => {
                        if (result === '1') {
                            return client.exec('cat /boot/alias').catch(_ => '')
                        }
                        return ''
                    })
                    const hostname: string = await client.exec('cat /etc/hostname').catch(_ => '')
                    return { hostname, snipsHostname }
                })
                .catch(_ => {
                    return { snipsHostname: '', hostname: '' }
                })
                return { ip, hostname: hostnames.hostname, snipsHostname: hostnames.snipsHostname }
            }),
        )
    }

    public async getCaptureLevel(card: number | undefined = 1): Promise<string> {
        return this.ssh.exec(`amixer -c ${card} cget name='Mic Capture Volume'`)
    }

    public async setCaptureLevel(card: number | undefined = 1, level: number | undefined = 80): Promise<string> {
        return this.ssh.exec(`amixer -c ${card} cset name='Mic Capture Volume' ${level}%`)
    }

    public async getVolumeLevel(card: number | undefined = 0): Promise<string> {
        return this.ssh.exec(`amixer -c ${card} cget name='PCM Playback Volume'`)
    }

    public async setVolumeLevel(card: number | undefined = 0, level: number | undefined = 90): Promise<string> {
        return this.ssh.exec(`amixer -c ${card} cset name='PCM Playback Volume' ${level}%`)
    }

    public async recordAudio(name: string): Promise<string> {
        return this.ssh.exec(`arecord -f cd ${name}.wav`)
    }

    public async stopRecording(): Promise<string> {
        return this.ssh.exec('pkill arecord')
    }

    public async testingtesting(): Promise<string> {
        return this.ssh.exec('sudo apt-get install ')
    }

    public async listCaptureDevices(): Promise<AudioDevice[]> {
        return this.ssh.exec("arecord -l | grep -E '^[^  ][^**]'")
        .then(success => {
            // card 0: ALSA [bcm2835 ALSA], device 0: bcm2835 ALSA [bcm2835 ALSA]
            if (success.length === 0) {
                throw new Error('No capture devices found. Check if your mic is correctly plugged.')
            }
            const devices = String(success).split('\n')
            if (devices.length === 0) {
                throw new Error('No capture devices found. Check if your mic is correctly plugged.')
            }
            try {
                return devices.map(device => new AudioDevice(device))
            } catch (e) {
                throw new Error(`Error reading the information of the audio device: ${e.message}`)
            }
        })
    }

    public async listOuputDevices(): Promise<AudioDevice[]> {
        return this.ssh.exec("aplay -l | grep -E '^[^  ][^**]'")
        .then(success => {
            const devices = String(success).split('\n')
            if (devices.length === 0) {
                throw new Error('No output devices found. This should not happen, on your device, run \narecord -l')
            }
            try {
                return devices.map(device => new AudioDevice(device))
            } catch (e) {
                throw new Error(`Error reading the information of the audio device: ${e.message}`)
            }
        })
    }

    public async launchSnipsWatch(listener: (string) => void): Promise<string> {
        return this.sshCommandLog(`${SnipsServices.watch} -vvv`, listener)
    }

    public async journalctlLogs(services: string[] | undefined, listener: (string) => void): Promise<string> {
        if (services !== undefined && services.length > 0) {
            const s = services.map(service => `-u ${service}`).join(' ')
            return this.sshCommandLog(`journalctl -f ${s}`, listener)
        }
        return this.sshCommandLog('journalctl -f -u "snips-*"', listener)
    }

    public async snipsServicesSystemctlStatus(): Promise<{ name: string, active: boolean }[]> {
        return Promise.all(availableSnipsServices
            .filter(service => service !== SnipsServices.template && service !== SnipsServices.watch)
            .map(async serviceName => {
                const active = await this.systemctlStatus(serviceName)
                return { active, name: serviceName }
            }))
    }

    public async systemctlStatus(service: string): Promise<boolean> {
        return await this.ssh.exec(`systemctl is-active ${service}.service >/dev/null 2>&1 && echo 'active' || echo 'inactive'`)
            .then(result => result === 'active')
    }

    public async playAudio(name: string): Promise<string> {
        // Playing audio throws back an error even though it executes the file. We ignore the error.
        return this.ssh.exec(`aplay ${name}.wav`)
        // .catch((e) => { });
    }

    public async removeAudioFile(name: string): Promise<string> {
        return this.ssh.exec(`rm ${name}.wav`)
    }

    public async setupAsoundConf(outputDevice: AudioDevice, captureDevice: AudioDevice): Promise<string> {
        const dest = '/etc/asound.conf'
        const contents =
`pcm.!default {
    type asym
    playback.pcm {
        type plug
        slave.pcm "hw:${outputDevice.card},${outputDevice.subdevice}"
    }
    capture.pcm {
        type plug
        slave.pcm "hw:${captureDevice.card},${captureDevice.subdevice}"
    }
}`
        return this.writeFileAsRoot(contents, dest)
    }

    public async getAssistantSnipsfile(): Promise<Snipsfile> {
        return this.getFile('/usr/share/snips/assistant/Snipsfile.yaml')
        .then(snipsfile => new Snipsfile(snipsfile))
    }

    public async copySnipsfile(snipsfile: string) {
        return this.ssh.exec(`echo "${snipsfile}" | sudo tee ~/Snipsfile > /dev/null`)
    }

    public async stopService(service: string): Promise<string> {
        return this.ssh.exec(`sudo systemctl stop ${service}.service`)
    }

    public async stopServices(services?: string[] | undefined): Promise<string> {
        if (services !== undefined && services.length > 0) {
            const restart = services.map(service => `sudo systemctl stop ${service}`).join(' ; ')
            return this.ssh.exec(restart)
        }
        return this.ssh.exec("sudo systemctl stop 'snips*'")
    }

    public async relaunchService(service: string): Promise<string> {
        return this.ssh.exec(`sudo systemctl restart ${service}.service`)
    }

    public async startServices(services?: string[] | undefined): Promise<string> {
        if (services !== undefined && services.length > 0) {
            const restart = services.map(service => `sudo systemctl start ${service}`).join(' ; ')
            return this.ssh.exec(restart)
        }
        return this.ssh.exec('sudo systemctl start snips-analytics snips-asr snips-audio-server snips-dialogue snips-nlu snips-tts snips-skill-server snips-hotword')
    }

    public async relaunchServices(services?: string[] | undefined): Promise<string> {
        if (services !== undefined && services.length > 0) {
            const restart = services.map(service => `sudo systemctl restart ${service}`).join(' ; ')
            return this.ssh.exec(restart)
        }
        return this.ssh.exec("sudo systemctl restart 'snips-*'")
    }

    public async updateSnips(listener: (string) => void): Promise<string> {
        return this.sshCommandLog(`sudo apt-get update; sudo apt-get -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confnew" upgrade -y snips-platform-voice ${SnipsServices.template} ${SnipsServices.skillServer}`, listener)
    }

    public async installSnips(listener: (string) => void, installSteps: (string) => void): Promise<string> {
        installSteps('Updating aptitude repository')
        return this.sshCommandLog('sudo apt-get update', listener)
        .then(_ => {
            installSteps('Installing dirmngr')
            return this.sshCommandLog('sudo apt-get install -y dirmngr', listener)
            .catch(_ => { throw new Error("Couldn't install dirmngr") })
        })
        .then(_ => {
            installSteps('Adding Snips APT source list')
            return this.sshCommandLog(`sudo bash -c  'echo "deb https://raspbian.snips.ai/$(lsb_release -cs) stable main" > /etc/apt/sources.list.d/snips.list'`, listener)
            .catch(_ => { throw new Error("Couldn't update Snips apt sources on the device") })
        })
        .then(_ => {
            installSteps('Adding Snips PGP public key')
            const tmpRemotePGPkeyPath = '/tmp/snips-pgp-key.asc'
            return this.ssh.exec(`(echo "${Assets.pgpKey()}" > ${tmpRemotePGPkeyPath}) && sudo apt-key add ${tmpRemotePGPkeyPath}; rm ${tmpRemotePGPkeyPath}`)
            .catch(_ => {
                // PGP will complain about the PGP key already being added or that the apt-key output should not be parsed
                // We can't safely catch these errors since it's language system dependant
            })

        })
        .then(_ => installSteps('Updating aptitude repository'))
        .then(_ => this.sshCommandLog('sudo apt-get update', listener))
        .then(_ => installSteps('Installing Snips Platform, this could take a while, grab a cup of tea & relax'))
        .then(_ => {
            return this.sshCommandLog(`sudo apt-get install -y snips-platform-voice ${SnipsServices.watch} ${SnipsServices.template} ${SnipsServices.skillServer}`, listener)
            .catch(err => { throw new Error(`There was a problem during Snips Platform installation ${err}`) })
        })
        .then(_ => installSteps('Adding current user to snips-skills-admin group for security'))
        .then(_ => this.addCurrentUserToSnipsSkillsAdminGroup())
        .then(async _ => {
            installSteps('Disabling Mosquitto persistence')
            await this.stopService('mosquitto')
            .then(_ => this.toggleMQTTLogPersistance(false))
            .catch(_ => {})
            await this.relaunchService('mosquitto').catch(_ => {})
            return this.relaunchServices()
        })
    }

    public async packagesVersion(): Promise<{ name: string, version: string }[]> {
        const formatOutput = (dpkgOutput: string): { name: string, version: string }[] => {
            return dpkgOutput
            .split('\n')
            .map(line => {
                const split = line.trim().split(' ')
                if (split.length >= 2) return { name: split[0], version: split[split.length - 1] }
                return { name: '', version: '' }
            })
            .filter(v => v.name !== '')
        }
        return this.ssh.exec(`dpkg -l | grep snips | awk '{printf("%- 30s %- 10s\\n", $2,$3)}'`)
        .then(output => formatOutput(output).filter(v => availableSnipsServices.includes(v.name)))
    }

    public async updateWifi(name: string, passphrase: string): Promise<string> {
        return this.ssh.exec(`(echo ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev; \
            echo update_config=1; \
            echo ; \
            wpa_passphrase \"${name}\" \"${passphrase}\") \
            | sudo tee /etc/wpa_supplicant/wpa_supplicant.conf > /dev/null`)
            .then(_ => {
                return this.ssh.exec('sudo wpa_cli reconfigure')
            })
    }

    public async statusWifi(): Promise<string> {
        return this.ssh.exec('sudo wpa_cli status')
        .then(response => {
            let ssid: string | undefined
            let status: string | undefined
            response.split('\n')
            .map(line => line.split('='))
            .forEach(lineComponents => {
                const key = lineComponents[0]
                const value = lineComponents[1]
                if (key === 'ssid') {
                    ssid = value
                } else if (key === 'wpa_state') {
                    // TODO add wpa_state
                    status = value
                }
            })
            return [ssid, status]
        })
    }

    public async reconnectWifi(): Promise<string> {
        return this.ssh.exec('sudo wpa_cli reconnect')
    }

    public async disconnectWifi(): Promise<string> {
        return this.ssh.exec('sudo wpa_cli disconnect')
    }

    public async putFile(localPath: string, remotePath: string): Promise<string> {
        return this.ssh.putFile(localPath, remotePath)
    }

    public async putString(string: string, remotePath: string) {
        return this.ssh.exec(`sudo sh -c "echo '${string}' > ${remotePath}"`)
    }

    public async getFile(remotePath: string): Promise<string> {
        return this.ssh.exec(`cat ${remotePath}`)
    }

    public async putDirectory(localDirectory: string, remoteDirectory: string): Promise<string> {
        return await this.ssh.putDirectory(localDirectory, remoteDirectory, {
            recursive: true,
            concurrency: 1, // /!\ Anything >1 will result in potentially failed transfered files, you've been warned
            validate: itemPath => {
                const baseName = path.basename(itemPath)
                return baseName.substr(0, 1) !== '.' // do not allow dot files
            },
        })
    }

    public async removeFile(remotePath: string): Promise<string> {
        return this.ssh.exec(`sudo rm "${remotePath}"`)
    }

    public async removeDirectory(remotePath: string): Promise<string> {
        return this.ssh.exec(`sudo rm -rf "${remotePath}"`)
    }

    public async unzipFile(filePath: string, destinationPath: string = '.'): Promise<string> {
        // Unzip overwrites already present files
        return this.ssh.exec(`unzip -o "${filePath}" -d "${destinationPath}"`)
    }

    public async installAssistant(assistantPath: string): Promise<string> {
        const assistantFilename: string = path.basename(assistantPath)
        const tmpDirPath = '/tmp/assistant/'

        return this.removeDirectory('/usr/share/snips/assistant')
        .then(_ => {
            if (assistantFilename.includes('zip')) {
                return this.removeDirectory(tmpDirPath)
                .then(_ => this.ssh.exec(`mkdir ${tmpDirPath}`))
                .then(_ => this.putFile(assistantPath, tmpDirPath + assistantFilename))
                .then(_ => this.unzipFile(tmpDirPath + assistantFilename, tmpDirPath))
                .then(_ => this.removeFile(tmpDirPath + assistantFilename))
            }
            return this.putDirectory(assistantPath, tmpDirPath)
            .then(status => {
                // PutDirectory is not sending an explicit error, so we catch it here.
                if (!status) {
                    throw new Error('Some files failed to transfer, aborting')
                }
                return 'success'
            })
        })
        .then(_ => this.ssh.exec(`sudo mv ${tmpDirPath}* /usr/share/snips`))
    }

    public async dpkgCheckIfPackageIsInstalled(packageName: string): Promise<boolean> {
        return this.ssh.exec(`if dpkg-query -W -f='\${db:Status-abbrev}' "${packageName}" 2>/dev/null | grep -q '^i'; then echo 1; else echo 0; fi`)
        .then(result => result === '1')
    }

    public async isFileExecutable(file: string): Promise<boolean> {
        return this.ssh.exec(`if [ -x "${file}" ]; then echo 1; else echo 0; fi`)
        .then(result => result === '1')
    }

    public async checkCommandExists(command: string): Promise<boolean> {
        return this.ssh.exec(`if [ -x "$(command -v ${command})" ]; then echo 1; else echo 0; fi`)
        .then(result => result === '1')
    }

    public async installRespeakerMicHat(listener: (string) => void): Promise<string> {
        return this.sshCommandLog('cd /tmp/; git clone https://github.com/respeaker/seeed-voicecard', listener)
        .then(_ => this.sshCommandLog('cd /tmp/seeed-voicecard; sudo ./install.sh; rm -rf /tmp/seeed-voicecard', listener))
    }

    public async run(command: string): Promise<string> {
        return this.ssh.exec(command)
    }

    private async sshCommandLog(command: string, listener: (string) => void): Promise<string> {
        return this.ssh.execCommand(command, {
            onStdout(chunk) {
                listener(chunk.toString('utf8'))
            },
            onStderr(chunk) {
                listener(chunk.toString('utf8'))
            },
        })
    }

    /*----------------------------------------------------------------------*/
    // Skill store related

    public async snipsTemplateRender(listener: (string) => void): Promise<string> {
        return this.sshCommandLog(`sudo -u _snips-skills bash -c '${SnipsServices.template} render'`, listener)
    }

    public async hasSnipsSkillsServerGroup(): Promise<boolean> {
        return this.ssh.exec('if grep -q snips-skills-admin /etc/group; then echo 1; else echo 0; fi')
        .then(result => result === '1')
    }

    public async addCurrentUserToSnipsSkillsAdminGroup(): Promise<string> {
        return this.hasSnipsSkillsServerGroup()
        .then(hasSnipsSKillsGroup => {
            if (!hasSnipsSKillsGroup) return 'failure'
            return this.ssh.exec('if id -nG "$USER" | grep -qw "snips-skills-admin"; then echo 1; else echo 0; fi')
            .then(result => result === '1')
            .then(isInGroup => {
                if (!isInGroup) return this.ssh.exec('sudo usermod -a -G snips-skills-admin $USER')
                return 'done'
            })
        })
    }

    public async detectConfigIniParameters(): Promise<string> {
        return this.ssh.run('find /var/lib/snips/skills -name config.ini')
        .then((configs: string) => {
            return configs.split('\n')
            .map(line => path.basename(line).replace(/\.[^/.]+$/, ''))
        })
    }

    public async gitClone(repository: string, branch: string | undefined, listener: (string) => void, permissionError: (string) => void) {
        const gitFolderName = path.basename(repository).replace(/\.[^/.]+$/, '')
        let gitClone = `sudo -u _snips-skills bash -c 'git clone --recursive "${repository}"'`
        if (branch !== undefined && branch.length > 0) {
            gitClone = `sudo -u _snips-skills bash -c 'git clone -b ${branch} --recursive "${repository}"'`
        }
        return this.sshCommandLog(`cd /var/lib/snips/skills/
if [ ! -d "${gitFolderName}" ]; then
	${gitClone}
else
	cd "${gitFolderName}"
    if [ $(git config --get remote.origin.url) = ${repository} ]; then
		sudo -u _snips-skills bash -c 'git pull'
    else
        cd ..
        sudo -u _snips-skills bash -c 'rm -rf "${gitFolderName}"'
		${gitClone}
	fi
fi`,                              listener)
        .then(_ => this.ssh.exec(`find /var/lib/snips/skills/${gitFolderName} -name "action*" ! -executable`))
        .then((actionsNotExecutable: string) => {
            if (actionsNotExecutable.length > 0) {
                if (actionsNotExecutable.length > 1) {
                    permissionError(`Warning: Some actions are not executable. Snips-skill-server won't be able to run them. Files: \n${actionsNotExecutable}`)
                } else {
                    permissionError(`Warning: The action ${actionsNotExecutable} is not executable. Snips-skill-server won't be able to run it.`)
                }
                listener('To change the permission on your device, run:')
                const actions = actionsNotExecutable.split('\n').join(' ')
                listener(`chmod +x ${actions}\n`)
            }
        })
    }

    public async runSkillSetupSH(skillFolder): Promise<string> {
        return this.ssh.exec(`cd /var/lib/snips/skills/${skillFolder}; sudo -u _snips-skills bash -c 'sh setup.sh'`)
    }

    public async getSnippets(): Promise<Map<string, { type: string, snippets: string[] }>> {
        return this.ssh.exec('cd /usr/share/snips/assistant/snippets; ls -d */*/*')
        .then((snippets: string) => {
            // returns for instance :
            // Smart_lights/python2/lightsTurnDown.snippet
            // Smart_lights/python2/lightsTurnOff.snippet
            if (snippets === undefined) throw new Error('No snippets found')
            if (snippets.length === 0) throw new Error('No snippets found')

            return snippets.split('\n')
            .map(line => {
                const parts = line.split('/')
                if (parts.length === 0 || parts.length < 3) throw new Error('No snippets found')

                return {
                    name: parts[0],
                    type: parts[1],
                    snippet: parts[2].replace(/.snippet/g, ''),
                }
            })
            .reduce((previous, next) => {
                let subArray = previous.get(next.name)
                if (subArray !== undefined) {
                    subArray.snippets.push(next.snippet)
                } else {
                    subArray = { type: next.type, snippets: [next.snippet] }
                }
                previous.set(next.name, subArray)
                return previous
            },      new Map<string, { type: string, snippets: string[] }>())
        })
    }

    public async getSkillConfig(skillFolder) {
        const dest = `/var/lib/snips/skills/${skillFolder}/config.ini`
        const exists = await this.fileExists(dest)
        return exists ?
            this.ssh.exec(`cat ${dest}`) :
            null
    }

    public async getSkillConfigNew(skillFolder) {
        const dest = `/var/lib/snips/skills/${skillFolder}/config.ini.new`
        const exists = await this.fileExists(dest)
        return exists ?
            this.ssh.exec(`cat ${dest}`) :
            null
    }

    public updateSkillConfig(config, skillFolder) {
        const dest = `/var/lib/snips/skills/${skillFolder}/config.ini`
        return this.writeFileAsSnipsSKills(config, dest)
    }

    public async getGeneratedSkills(): Promise<string[]> {
        return this.ssh.exec('cd /var/lib/snips/skills; ls -1d ./*/')
        .then((skillPath: string) => {
            if (skillPath.length === 0) return undefined
            return skillPath.split('\n')
            .map(line => path.basename(line))
        })
    }

    public async toggleMQTTLogPersistance(toggle: boolean): Promise<string> {
        const toggleString = Boolean(toggle).toString()
        return this.ssh.exec(`sudo sed -i "s#.*persistence .*#persistence ${toggleString}#g" /etc/mosquitto/mosquitto.conf`)
    }

    public async deleteMosquittoDB(): Promise<string> {
        return this.ssh.exec('sudo rm /var/lib/mosquitto/mosquitto.db')
    }
    /*----------------------------------------------------------------------*/
    // Echo cancellation installation
    public async tuneEchoCancel(source: string, sink: string, listener: (string) => void) {
        // change default sink and source
        await this.sshCommandLog(`sudo sed -i.bak 's/^;\\?\\s*default-sink.*/default-sink = ${sink}.echo-cancel/' /etc/pulse/client.conf`, listener)
        await this.sshCommandLog(`sudo sed -i.bak 's/^;\\?\\s*default-source.*/default-source = ${source}.echo-cancel/' /etc/pulse/client.conf`, listener)

        await this.sshCommandLog(`sudo sed -i.bak 's/^mic=".*"/mic="${source}"/' /usr/local/bin/pulse-aec.sh`, listener)
        await this.sshCommandLog(`sudo sed -i.bak 's/^speaker=".*"/speaker="${sink}"/' /usr/local/bin/pulse-aec.sh`, listener)

        await this.sshCommandLog('sudo systemctl stop snips-audio-server.service', listener)
        await this.sshCommandLog('sudo systemctl stop pulseaudio.service', listener)
        await this.sshCommandLog('sudo systemctl restart pulseaudio.service', listener)
        await this.sshCommandLog('sudo systemctl restart pulseaudio-aec.service', listener)
        await this.sshCommandLog('sudo systemctl restart snips-audio-server.service', listener)
        await this.sshCommandLog('sudo systemctl restart snips-audio-server.service', listener)
    }

    public async setupEchoCancel(source: string, sink: string, listener: (string) => void) {
        await this.sshCommandLog('sudo apt-get update', listener)
        await this.sshCommandLog('sudo apt-get install -y --reinstall pulseaudio', listener)
        await this.sshCommandLog('sudo systemctl stop pulseaudio.service', listener)
        await this.sshCommandLog('sudo systemctl stop snips-audio-server.service', listener)
        await this.sshCommandLog('pulseaudio -k', listener)
        await this.sshCommandLog('sudo killall pulseaudio', listener)

        // Do NOT run pulseaudio in realtime mode as it will crash on loading echo cancellation
        await this.writeFileAsRoot(Assets.pulseaudioService(), '/lib/systemd/system/pulseaudio.service')

        // Comment the lines that overwrite the asound.conf in case we're using seeed
        await this.sshCommandLog("sudo sed -i.bak 's/^\\(.*asound\\.conf.*\\)/# \\1/' /usr/bin/seeed-voicecard", listener).catch(() => {})

        // redirect alsa traffic to pulseaudio through the pulse alsa module
        await this.sshCommandLog('sudo rm /etc/asound.conf || true', listener)
        await this.writeFileAsRoot(Assets.pulseaudioAsoundConf(), '/etc/asound.conf')

        // Allow users access to pulseaudio on next login
        await this.sshCommandLog('sudo usermod -a -G pulse-access _snips', listener)
        await this.sshCommandLog('sudo usermod -a -G pulse-access pi', listener)
        await this.sshCommandLog('sudo usermod -a -G pulse-access root', listener)

        // Change default sample rate to something higher
        await this.sshCommandLog("sudo sed -i.bak 's/^;\\?\\s*default-sample-rate.*/default-sample-rate = 48000/' /etc/pulse/daemon.conf", listener)

        // Add a script to enable the echo cancellation module once pulseaudio has loaded the soundcard
        const pulseScript =
`#!/bin/bash

# name of the mic and speaker to use
mic="${source}"
speaker="${sink}"

# wait for the source to exist
for (( ; ; ))
do
   sleep 1
   found=\`pactl list sources | grep Name: | grep -v ".monitor" | grep \$\{mic} | wc -l \`
   if [ "$found" == "1" ]
   then
        break
   fi
done

sleep 2

# load the echo-cancel module
pactl load-module \\
    module-echo-cancel \\
    source_master=\$\{mic} \\
    sink_master=\$\{speaker} \\
    aec_method=webrtc \\
    use_master_format=1 \\
    aec_args='"high_pass_filter=1 noise_suppression=0 analog_gain_control=0"'
`
        await this.writeFileAsRoot(pulseScript, '/usr/local/bin/pulse-aec.sh')

        // The script is owned by the pulseaudio system user
        await this.sshCommandLog('sudo chmod +x /usr/local/bin/pulse-aec.sh', listener)
        await this.sshCommandLog('sudo chown pulse:pulse /usr/local/bin/pulse-aec.sh', listener)

        // Add a service file to run the aec script before the audio server but after pulseaudio

        await this.writeFileAsRoot(Assets.pulseaudioAecService(), '/lib/systemd/system/pulseaudio-aec.service')

        // Only run the audio server once echo cancellation is loaded
        this.writeFileAsRoot(Assets.pulseaudioSnipsAudioServerService(), '/etc/systemd/system/multi-user.target.wants/snips-audio-server.service')

        // change default sink and source
        await this.sshCommandLog(`sudo sed -i.bak 's/^;\\?\\s*default-sink.*/default-sink = ${sink}.echo-cancel/' /etc/pulse/client.conf`, listener)
        await this.sshCommandLog(`sudo sed -i.bak 's/^;\\?\\s*default-source.*/default-source = ${source}.echo-cancel/' /etc/pulse/client.conf`, listener)

        await this.sshCommandLog('sudo systemctl daemon-reload', listener)
        await this.sshCommandLog('systemctl --user disable pulseaudio', listener)
        await this.sshCommandLog('sudo systemctl enable pulseaudio.service', listener)
        await this.sshCommandLog('sudo systemctl enable pulseaudio-aec.service', listener)
        await this.sshCommandLog('sudo systemctl enable snips-audio-server.service', listener)

        await this.sshCommandLog('sudo systemctl restart pulseaudio.service', listener)
        await this.sshCommandLog('sudo systemctl restart pulseaudio-aec.service', listener)
        await this.sshCommandLog('sudo systemctl restart snips-audio-server.service', listener)
    }

    public async listPulseSources(): Promise<{ name: string, description: string}[]> {
        const res = await this.ssh.execCommand("LC_ALL=C.UTF8 ; pactl list sources | grep '^\\s*\\(Name\\|Description\\)' | sed 's/\\s*\\S*:\\s//' - | xargs -n2 -d'\\n' | grep -v '.monitor' | grep -v '.echo-cancel'")
        const str = res.stdout
        return str.split('\n').map(s => {
            return {
                name: s.substr(0, s.indexOf(' ')),
                description: s.substr(s.indexOf(' ') + 1),
            }
        })
    }

    public async listPulseSinks(): Promise<{ name: string, description: string}[]>  {
        const res = await this.ssh.execCommand("LC_ALL=C.UTF8 ; pactl list sinks | grep '^\\s*\\(Name\\|Description\\)' | sed 's/\\s*\\S*:\\s//' - | xargs -n2 -d'\\n' | grep -v '.monitor' | grep -v '.echo-cancel'")
        const str = res.stdout
        return str.split('\n').map(s => {
            return {
                name: s.substr(0, s.indexOf(' ')),
                description: s.substr(s.indexOf(' ') + 1),
            }
        })
    }

    /*----------------------------------------------------------------------*/
    // Home assistant related

    public async moveSkillsToHomeAssistantFolder(pythonFolder: string, skillNames: string[]) {
        return this.folderExists(pythonFolder)
        .then(pythonFolderExists => {
            if (!pythonFolderExists) return this.ssh.exec(`sudo mkdir ${pythonFolder}`)
            return ''
        })
        .then(async _ => {
            const moveFolders = skillNames.map(name => `/var/lib/snips/skills/${name}/*.py`).join(' ')
            return this.ssh.exec(`sudo mv -t ${pythonFolder} ${moveFolders}`)
        })
    }

    public async readHASSConfig(): Promise<string> {
        return this.ssh.exec('')
    }

    public async backupHassConfiguration(hassConfigurationPath: string): Promise<string> {
        return this.ssh.exec(`cd ${hassConfigurationPath}; sudo cp configuration.yaml configuration.yaml.bak-$(date +%-Y%-m%-d)-$(date +%-T)`)
    }

    public async folderExists(remoteFilePath: string): Promise<boolean> {
        return this.ssh.exec(`if [ -d "${remoteFilePath}" ]; then echo 1; else echo 0; fi`)
        .then(result => result === '1')
    }

    public async fileExists(remoteFilePath: string): Promise<boolean> {
        return await this.ssh.exec(`if [ -f "${remoteFilePath}" ]; then echo 1; else echo 0; fi`) === '1'
    }

    public async restartHomeAssistant(): Promise<string> {
        return this.ssh.exec('sudo systemctl restart home-assistant@homeassistant.service')
    }

    public async updateHomeAssistant(listener: (string) => void) {
        return this.sshCommandLog(this.hassBashCmd('cd /srv/homeassistant; source bin/activate; pip3 install --upgrade homeassistant'), listener)
    }

    public async installPythonAndPip(listener: (string) => void) {
        return this.sshCommandLog('sudo apt-get install -y python3-pip python3-venv python-pip; sudo pip install virtualenv', listener)
    }

    public async installHomeAssistant(listener: (string) => void, installStep: (string) => void): Promise<string> {
        installStep('Updating APT repositories')
        return this.sshCommandLog('sudo apt-get update', listener)
        .then(_ => installStep('Installing python3-pip, python3-venv'))
        .then(_ => this.sshCommandLog('sudo apt-get install -y python3-pip python3-venv', listener))
        .then(_ => installStep('Adding homeassistant user'))
        .then(_ => this.sshCommandLog('sudo useradd -rm homeassistant', listener))
        .then(_ => this.sshCommandLog('cd /srv; sudo mkdir homeassistant; sudo chown homeassistant:homeassistant homeassistant', listener))
        .then(_ => installStep('Installing Home Assistant'))
        .then(_ => this.sshCommandLog(this.hassBashCmd('cd /srv/homeassistant; python3 -m venv .; source bin/activate; python3 -m pip install wheel; pip3 install homeassistant'), listener))
        .then(_ => installStep('Adding Hass systemd service to enable autostart'))
        .then(_ => this.sshCommandLog(`echo '${Assets.homeAssistantPythonSystemdService()}' | sudo tee /etc/systemd/system/home-assistant@homeassistant.service > /dev/null`, listener))
        .then(_ => this.ssh.exec('sudo systemctl --system daemon-reload; sudo systemctl enable home-assistant@homeassistant.service')
                    .catch(_ => {}))
        .then(_ => installStep(`Launching Hass, it can take a while the first time. Check http://${this.credentials.hostname}:8123 to see when it's up.`))
        .then(_ => this.ssh.exec('sudo systemctl start home-assistant@homeassistant.service'))
    }

    private hassBashCmd(command: string): string {
        return `sudo su -c '${command}' -s /bin/bash homeassistant`
    }

    /*----------------------------------------------------------------------*/
    // ASR Benchmark

    public async playWAVtoASR(remoteWAVPath: string): Promise<string> {
        return this.ssh.exec(`cat ${remoteWAVPath} | nc localhost 1234`)
    }

    public async journalctlLog(service: string, listener: (string) => void): Promise<string> {
        return this.sshCommandLog(`journalctl -S now -o cat -f -u ${service}.service`, listener)
    }

    public async editAudioServerService(): Promise<string> {
        return this.ssh.exec(`sudo sed -i "s#.*ExecStart=/usr/bin/${SnipsServices.audioServer}.*#ExecStart=/usr/bin/${SnipsServices.audioServer} --hijack localhost:1234 --nomike#g" /lib/systemd/system/${SnipsServices.audioServer}.service; \
        sudo systemctl daemon-reload; \
        sudo systemctl restart ${SnipsServices.audioServer}.service`)
    }

    public async resetAudioServerService(): Promise<string> {
        return this.ssh.exec(`sudo sed -i "s#.*ExecStart=/usr/bin/${SnipsServices.audioServer}.*#ExecStart=/usr/bin/${SnipsServices.audioServer}#g" /lib/systemd/system/${SnipsServices.audioServer}.service; \
        sudo systemctl daemon-reload; \
        sudo systemctl restart ${SnipsServices.audioServer}.service`)
    }

    public async editASRService(maxActive: number, minActive: number): Promise<string> {
        return this.ssh.exec(`sudo sed -i "s#.*ExecStart=/usr/bin/${SnipsServices.asr}.*#ExecStart=/usr/bin/${SnipsServices.asr} --max_active ${maxActive} --min_active ${minActive}#g" /lib/systemd/system/${SnipsServices.asr}.service; \
        sudo systemctl daemon-reload; \
        sudo systemctl restart ${SnipsServices.asr}.service`)
    }

    public async resetASRService(): Promise<string> {
        return this.ssh.exec(`sudo sed -i "s#.*ExecStart=/usr/bin/${SnipsServices.asr}.*#ExecStart=/usr/bin/${SnipsServices.asr}#g" /lib/systemd/system/${SnipsServices.asr}.service; \
        sudo systemctl daemon-reload; \
        sudo systemctl restart ${SnipsServices.asr}.service`)
    }

    public async publishMQTTStartListening(): Promise<string> {
        return this.ssh.exec(`mosquitto_pub -h 127.0.0.1 -t 'hermes/asr/startListening' -m '{ "siteId":"default", "sessionId": "some_session" }'`)
    }

    public async killNCServer(): Promise<string> {
        return this.ssh.exec('pkill nc')
    }

    /*----------------------------------------------------------------------*/
    // RSA Key Generation

    public async sshCopyId(onSSHKeygenExeNotFound: (string) => Promise<string>): Promise<string> {
        let sshPubKeyFile: string
        if (!fsExtra.existsSync(snipsRSAKeyFilePath)) {
            sshPubKeyFile = await this.sshKeygen(onSSHKeygenExeNotFound)
        } else {
            sshPubKeyFile = fsExtra.readFileSync(`${snipsRSAKeyFilePath}.pub`, 'utf8')
        }

        // The ssh-copy-id script doesn't exist on Windows, the Unix script essentially copies the keys on the remote server with ssh
        // You can check the original code on your own system : cat /usr/bin/ssh-copy-id
        // The command below is the same as the osx version.
        const command = `echo "${sshPubKeyFile}" | exec sh -c 'cd ; umask 077 ; mkdir -p .ssh && cat >> ${snipsRemoteAuthorizedKeysFilename} || exit 1 ; if type restorecon >/dev/null 2>&1 ; then restorecon -F .ssh ${snipsRemoteAuthorizedKeysFilename} ; fi'`
        return this.ssh.exec(command)
    }

    private async sshKeygen(onSSHKeygenExeNotFound: (string) => Promise<string>): Promise<string> {
        let command = `ssh-keygen -m PEM -t rsa -b 4096 -C "Snips RSA key" -N "" -f "${snipsRSAKeyFilePath}"`

        if (process.platform === 'win32') {
            // We use the url of default Git installation
            let sshKeygenPath: string
            switch (process.arch) {
                case 'ia32':
                case 'x64':
                    sshKeygenPath = 'C:\\Program Files\\Git\\usr\\bin\\ssh-keygen.exe'
                    break
                default: throw new Error('Unsupported platform')
            }

            let pathValid = false
            while (!pathValid) {
                try {
                    fsExtra.accessSync(sshKeygenPath, fsExtra.constants.R_OK | fsExtra.constants.W_OK)
                    pathValid = true
                } catch (e) {
                    sshKeygenPath = await onSSHKeygenExeNotFound(sshKeygenPath)
                }
            }
            fsExtra.ensureDirSync(path.join(os.homedir(), '.ssh'))

            command = `"${sshKeygenPath}" -m PEM -t rsa -b 4096 -C "Snips RSA key" -N "" -q -f "${snipsRSAKeyFilePath}"`
        }

        shelljs.exec(command, { async: false, silent: false })
        try {
            return fsExtra.readFileSync(`${snipsRSAKeyFilePath}.pub`, 'utf8')
        } catch (e) {
            throw new Error("Snips RSA key couldn't be found")
        }
    }
}
