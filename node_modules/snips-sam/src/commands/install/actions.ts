import * as yargs from 'yargs'
import { cli } from '../../cli'
import { SSHService, SnipsServices } from '../../session'
import chalk from 'chalk'
import * as shelljs from 'shelljs'
import { HassConfiguration } from '../../models/hassConfiguration'
import { timeout } from '../../utils'
import { Snipsfile } from '../../models'
import * as ini from 'ini'

exports.command = 'actions'
exports.desc = 'Install actions present on the device'
exports.aliases = 'skills'

exports.builder = {
    git: {
        demandOption: false,
        describe: 'Install an action from a git repository',
        type: 'string',
        alias: 'g',
    },

    branch: {
        demandOption: false,
        describe: 'Specify the git branch you want to use',
        type: 'string',
        alias: 'b',
    },

    ignore_action_parameters: {
        demandOption: false,
        describe: 'Do not get prompted for action parameters',
        type: 'boolean',
        alias: 'ignore',
        default: false,
    },
}

exports.handler = async (argv: yargs.Argv) => {
    const git: string = JSON.parse(JSON.stringify(argv)).git
    const branch: string = JSON.parse(JSON.stringify(argv)).branch
    const ignore: boolean = JSON.parse(JSON.stringify(argv)).ignore_action_parameters

    const ssh = new SSHService()
    await ssh.connect()
    .catch(e => {
        cli.stream.error(e)
        process.exit()
    })

    try {
        const skillSetup = new SkillSetup(ssh, ignore, git, branch)
        await skillSetup.run()
        const assistant = await ssh.getInstalledAssistant()
        if (assistant !== undefined) {
            cli.stream.success(`Snips assistant is now running. Say ${chalk.blue(assistant.hotword)} to start!`)
        } else {
            cli.stream.success('Snips assistant is now running')
        }
    } catch (error) {
        cli.stream.error(error)
    }

    ssh.disconnect()
    process.exit()
}

export type SkillSnippet = { type: string, snippets: string[] }

export class SkillSetup {

    snippets: void | Map<string, SkillSnippet>
    snipsfile: Snipsfile
    hasPythonSkill: boolean
    hasHassSkill: boolean
    hasGitSkill: boolean
    hasJsSkill: boolean
    singleGitInstall: boolean

    hassSnippets: Map<string, string[]> = new Map<string, string[]>()

    hassCfgPath = '/home/homeassistant/.homeassistant/'

    constructor(
        private ssh: SSHService,
        private ignore: boolean,
        private git?: string,
        private branch?: string) {
    }

    async run() {

        this.singleGitInstall = (this.git !== undefined && this.git.length > 0)

        if (!this.singleGitInstall) cli.stream.println(chalk.green('Checking for actions'))
        const snipsfile = await this.ssh.getAssistantSnipsfile()
        .catch(e => cli.stream.error(`Error reading the Snipsfile for skills, reason: ${e.message}`))

        this.snippets = await this.ssh.getSnippets().catch(_ => {})

        if (!this.singleGitInstall) {
            this.snippets && this.snippets.forEach((skill, key) => {
                if (skill.type.includes('python')) {
                    this.hasPythonSkill = true
                    let snippetPlural = 'snippet:'
                    if (skill.snippets.length > 1) snippetPlural = 'snippets:'
                    cli.stream.println(`Python skill ${key} has ${skill.snippets.length} ${snippetPlural}`)
                    skill.snippets.forEach(snippet => cli.stream.println(`\t${snippet}`))
                }
                if (skill.type.includes('homeassistant')) {
                    this.hasHassSkill = true
                    this.hassSnippets.set(key, skill.snippets)
                    let snippetPlural = ' snippet:'
                    if (skill.snippets.length > 1) snippetPlural = ' snippets:'
                    cli.stream.println(`Home Assistant skill ${key} has ${skill.snippets.length} ${snippetPlural}`)
                    skill.snippets.forEach(snippet => cli.stream.println(`\t${snippet}`))
                }
                if (skill.type.includes('javascript')) {
                    this.hasJsSkill = true
                    let snippetPlural = 'snippet:'
                    if (skill.snippets.length > 1) snippetPlural = 'snippets:'
                    cli.stream.println(`Javascript skill ${key} has ${skill.snippets.length} ${snippetPlural}`)
                    skill.snippets.forEach(snippet => cli.stream.println(`\t${snippet}`))
                }
            })
        }

        this.hasGitSkill = snipsfile !== undefined && snipsfile.skills.length > 0

        try {
            const templateInstalled = await this.ssh.dpkgCheckIfPackageIsInstalled(SnipsServices.template)
            if (!templateInstalled) {
                cli.stream.loading(`Installing ${SnipsServices.template} and ${SnipsServices.skillServer}`)
                await this.ssh.aptGetY([SnipsServices.template, SnipsServices.skillServer], _ => {})
                cli.stream.success()
                await this.ssh.addCurrentUserToSnipsSkillsAdminGroup().catch(_ => {})
            }
            //     cli.stream.hint('Your device architecture might not be supported by those two packages, please contact us')
            //     throw new Error(`Can't install packages ${SnipsServices.template} and ${SnipsServices.skillServer}, error : ${e.message}`)
            // })
        } catch (e) {
            // TODO: handle aptget error codes
        }

        await this.ssh.stopService(SnipsServices.skillServer)

        if (this.hasGitSkill || this.singleGitInstall) {
            if (!await this.ssh.checkCommandExists('git')) {
                cli.stream.loading('Installing git package')
                await this.ssh.aptGetY(['git'], _ => {})
                cli.stream.success()
            }
            if (snipsfile !== undefined && snipsfile.skills.length > 0 && !this.singleGitInstall) {
                for (const skill of snipsfile.skills) {
                    if (skill.url) {
                        cli.stream.println(`Cloning skill ${skill.name} from url: ${skill.url}`)
                        await this.ssh.gitClone(skill.url, undefined, output => cli.stream.println(output), permissionError => cli.stream.warning(permissionError))
                    }
                }
            }
            if (this.git !== undefined && this.git.length > 0) {
                cli.stream.println(`Cloning skill from url: ${this.git}`)
                await this.ssh.gitClone(this.git, this.branch, output => cli.stream.println(output), permissionError => cli.stream.warning(permissionError))
            }
        }

        if (this.snippets !== undefined && !this.singleGitInstall) {
            cli.stream.println(chalk.green('Generating actions based on the snippets, copying the actions in /var/lib/snips/skills'))
            await this.ssh.snipsTemplateRender(l => cli.stream.print(l))
            .catch(e => cli.stream.error(`Unable to generate the python action, reason: ${e.message}`))

            if (this.hasPythonSkill) {
                cli.stream.println(chalk.green('\nSetting up Python actions'))
            }
            if (this.hasJsSkill) {
                cli.stream.println(chalk.green('\nSetting up Javascript actions'))
            }

            if (this.hasHassSkill) {
                cli.stream.println(chalk.green('\nSetting up Home Assistant actions'))
                await this.setupHomeAssistantSkill()
                .then(_ => cli.stream.loading('Relaunching Home Assistant'))
                .then(_ => this.ssh.restartHomeAssistant())
                .then(_ => cli.stream.success())
                .catch(e => cli.stream.error(`Unable to install Home Assistant action, reason: ${e.message}`))
            }
        }

        const generatedSkills = await this.ssh.getGeneratedSkills().catch(_ => _)
        try {
            if (generatedSkills !== undefined && generatedSkills.length > 0) {
                await this.ssh.checkCommandExists('virtualenv')
                .then(isVirtualEnvInstalled => {
                    if (!isVirtualEnvInstalled) {
                        cli.stream.loading('Installing pip and virtualenv. This could take a while.')
                        return this.ssh.installPythonAndPip(_ => {})
                        .then(_ => cli.stream.success())
                    }
                    return
                })
                .catch(e => cli.stream.error(`Unable to install python-pip & virtualenv, reason: ${e.message}`))
            }
        } catch (error) {
            cli.stream.error(error.message)
        }

        if ((this.hasPythonSkill || this.hasGitSkill || this.singleGitInstall || this.hasJsSkill)
        && (generatedSkills !== undefined && generatedSkills.length > 0)) {
            try {
                await this.runSetupSH(generatedSkills)
                cli.stream.println(chalk.green('\nChecking actions for end-user parameters'))
                if (!this.ignore) {
                    await this.promptForParameters(generatedSkills)
                }
                cli.stream.println('Relaunching snips-skill-server')
                await this.ssh.relaunchService(SnipsServices.skillServer)
            } catch (error) {
                cli.stream.error(error.message)
            }
        }
    }

    async runSetupSH (generatedSkills) {
        if (generatedSkills) {
            for (const key of generatedSkills) {
                try {
                    cli.stream.println(chalk.green(`Running setup.sh for ${key}`))
                    const result = await this.ssh.runSkillSetupSH(key)
                    cli.stream.println(`setup.sh output:\n${result}`)
                } catch (error) {
                    cli.stream.error(`Error setting up ${key}, one or more actions might not be able to run. Reason :\n${error.message}`)
                }
            }
        }
    }

    async updateConfigForSection(section, folder, skillName = folder) {
        const rawConfig = await this.ssh.getSkillConfig(folder)
        const config = rawConfig && ini.parse(rawConfig)
        const configPath = `/var/lib/snips/skills/${folder}/config.ini`
        if (config && config[section] && Object.keys(config[section]).length > 0) {
            cli.stream.hint(`Action ${skillName} contains ${section} parameters that needs to be configured`)
            const lines = Object.entries(config[section])
            const answers = await cli.prompt.promptQuestions(lines.map(([key, val]) => ({
                name: key,
                default: val,
                message: `Please enter a value for the parameter [${key}]`,
            })))
            Object.entries(answers).forEach(([key, value]) => {
                config[section][key] = value
            })
            cli.stream.hint(`You can change these values later by editing the file located at ${configPath}`)
            const newConfig = ini.stringify(config)
            await this.ssh.updateSkillConfig(newConfig, folder)
        }
    }

    async promptForParameters (generatedSkills) {
        if (generatedSkills) {
            for (const key of generatedSkills) {
                await this.updateConfigForSection('global', key)
                await this.updateConfigForSection('secret', key)
            }
        }
    }

    async setupHomeAssistantSkill() {
        // Check for existing Hass configuration file
        await this.ssh.fileExists(`${this.hassCfgPath}configuration.yaml`)
        .then(exists => {
            if (!exists) return this.askUserForCustomHassInstallConfigurationPath()
            cli.stream.success('Found Home Assistant configuration.yaml')
            return this.hassCfgPath
        })
        .then(cfgFilePath => {
            if (cfgFilePath === undefined) return this.installHass()
            return cfgFilePath
        })
        .then(cfgFilePath => this.hassCfgPath = cfgFilePath.replace(/\/?$/, '/'))
        .then(_ => cli.stream.println('Moving generated actions to Hass python_script folder'))
        .then(_ => this.ssh.moveSkillsToHomeAssistantFolder(`${this.hassCfgPath}python_scripts`, Array.from(this.hassSnippets.keys())))
        .then(_ => cli.stream.println('Backing up your last Hass configuration'))
        .then(_ => this.ssh.backupHassConfiguration(this.hassCfgPath))
        .then(_ => this.ssh.getFile(`${this.hassCfgPath}configuration.yaml`))
        .then(file => {
            const parsedYamlFile = HassConfiguration.parse(file)
            if (parsedYamlFile === undefined) throw new Error('Error parsing the Home Assistant configuration')
            return parsedYamlFile
        })
        .then(hassCfgFile => {
            cli.stream.println('Creating new Hass configuration')
            return this.ssh.getInstalledAssistant()
            .then(assistantFile => {
                return HassConfiguration.generateSnipsConfiguration(hassCfgFile, assistantFile, this.hassSnippets)
            })
        })
        .then(newYamlFilePath => {
            return this.ssh.putFile(newYamlFilePath, '/tmp/configuration.yaml')
            .then(_ => shelljs.rm(newYamlFilePath))
            .then(_ => this.ssh.run(`sudo mv /tmp/configuration.yaml ${this.hassCfgPath}`))
        })
    }

    private async askUserForCustomHassInstallConfigurationPath(): Promise<string | undefined> {
        return cli.prompt.promptQuestions([
            {
                name: 'isInstalled',
                type: 'confirm',
                message: 'Is Home Assistant already installed on this device?',
            },
        ])
        .then(isHassInstalled => {
            if (isHassInstalled['isInstalled']) {
                let hassCfgFound = false
                return cli.prompt.promptQuestions([
                    {
                        name: 'hassCfgPath',
                        type: 'input',
                        message: 'Enter the path to Home Assistant configuration file.',
                        validate: async value => {
                            if (value.length === 0) return "Path can't be blank"
                            const pathWithSlash = value.replace(/\/?$/, '/')
                            hassCfgFound = await this.ssh.fileExists(`${pathWithSlash}configuration.yaml`)
                            if (!hassCfgFound) return `Didn't find ${pathWithSlash}configuration.yaml on the device`
                            return true
                        },
                    },
                ])
                .then(cfgPathResponse => cfgPathResponse['hassCfgPath'])
            }
            return undefined
        })
    }

    private async installHass(): Promise<string> {
        const hassInstallation = await cli.prompt.promptQuestions([
            {
                name: 'installHass',
                type: 'confirm',
                message: 'You need to install Home Assistant to continue, proceed?',
            },
        ])
        if (!hassInstallation['installHass']) {
            cli.stream.println('Quitting')
            cli.stream.hint(`You can install Home Assistant by running ${chalk.blue('sam hass install')}`)
            throw new Error("Hass isn't installed, aborting")
        }

        cli.stream.println('Installing Home Assistant, this can take a while')
        return await this.ssh.installHomeAssistant(
            _ => {},
            stepTitle => {
                cli.stream.println(chalk.green(stepTitle))
            })
            .then(async _ => {
                let loadingText = 'Waiting for Home Assistant initial setup. This could take a while.'
                cli.stream.loading(loadingText)
                let homeAssistantConfigurationDetected = false
                while (!homeAssistantConfigurationDetected) {
                    await timeout(5000)
                    homeAssistantConfigurationDetected = await this.ssh.fileExists('/home/homeassistant/.homeassistant/configuration.yaml')
                    loadingText += ' . '
                    cli.stream.loading(loadingText)
                }
                cli.stream.success()
                return 'success'
            })
            .then(_ => this.hassCfgPath)
    }
}
