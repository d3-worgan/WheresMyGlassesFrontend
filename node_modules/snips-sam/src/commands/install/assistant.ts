import * as yargs from 'yargs'
import { cli } from '../../cli'
import { SSHService, ConsoleClient } from '../../session'
import chalk from 'chalk'
import * as shelljs from 'shelljs'
import { SkillSetup } from './actions'

exports.command = 'assistant'
exports.desc = 'Install an assistant from different locations: console (with or without a project id) or a local file path.'
exports.builder = {
    path: {
        demandOption: false,
        describe: 'Path to local assistant folder, can be a zip',
        type: 'string',
        conflicts: 'id',
        alias: 'p',
    },
    id: {
        demandOption: false,
        describe: 'Your assistant id from the console, format: proj_XXXX',
        type: 'string',
        conflicts: 'path',
        alias: 'i',
    },

    ignore_action_parameters: {
        demandOption: false,
        describe: 'Do not get prompted for action parameters',
        type: 'boolean',
        alias: 'ignore',
        default: false,
    },
}

exports.handler = async (argv: yargs.Argv) => {
    const argsPath: string = JSON.parse(JSON.stringify(argv)).path
    const id: string = JSON.parse(JSON.stringify(argv)).id
    const ignore: boolean = JSON.parse(JSON.stringify(argv)).ignore_action_parameters

    const ssh = new SSHService()
    await ssh.connect()
    .catch(e => {
        cli.stream.error(e)
        process.exit()
    })

    let assistantPath: string

    if (argsPath !== undefined && argsPath.length > 0) {
        assistantPath = argsPath
    } else {
        // The user either provides an id, or we connect to the console so he can choose one
        if (cli.config.user === undefined) {
            cli.stream.error(`No user information to connect to the console, you must login first with ${chalk.blue('sam login')}`)
            process.exit(0)
            return
        }
        const client = new ConsoleClient()

        let assistantId: string
        if (id !== undefined && id.length > 0) {
            assistantId = id
        } else {
            try {
                cli.stream.loading('Fetching assistants')
                assistantId = await client.assistantList(cli.config.user.id)
                .then(async assistants => {
                    cli.stream.done()
                    const assistantNames = assistants.map(assistant => assistant.title)
                    if (assistantNames.length === 0) throw new Error('No assistants found on your account.')
                    if (assistantNames.length === 1) {
                        cli.stream.println(`Found 1 assistant named ${assistants[0].title}`)
                        return assistants[0].id
                    }

                    return await cli.prompt.promptList('assistant', 'Choose the assistant you wish to install on the device', assistantNames)
                    .then(response => {
                        const assistantSelected = assistants.find(value => value.title === response['assistant'])
                        if (assistantSelected === undefined) throw new Error('No assistant choosen')
                        return assistantSelected.id
                    })
                })
            } catch (e) {
                cli.stream.error(`Error fetching the assistant, reason: ${e.message}`)
                process.exit(0)
                return
            }
        }

        cli.stream.println('Downloading assistant')
        const assistantPathVoid = await client.downloadAssistant(
            assistantId,
            steps => {
                cli.stream.done()
                cli.stream.loading(steps)
            })
            .catch(e => cli.stream.error(e))
        if (assistantPathVoid) {
            assistantPath = assistantPathVoid
        } else {
            process.exit(0)
            return
        }
    }

    cli.stream.loading(`Deploying assistant to ${ssh.credentials.hostname}...`)
    await ssh.installAssistant(assistantPath)
    .then(_ => {
        if (argsPath !== undefined && argsPath.length > 0) return
        shelljs.rm('-rf', assistantPath)
    })
    .then(_ => cli.stream.success())
    .catch(e => {
        cli.stream.error(`Unable to install the assistant: ${e.message}`)
        ssh.disconnect()
        process.exit()
    })

    try {
        const skillSetup = new SkillSetup(ssh, ignore)
        await skillSetup.run()

        await ssh.relaunchServices().catch(_ => {})
        const assistant = await ssh.getInstalledAssistant()
        if (assistant !== undefined) {
            cli.stream.success(`Snips assistant is now running. Say ${chalk.blue(assistant.hotword)} to start!`)
        } else {
            cli.stream.success('Snips assistant is now running')
        }

        cli.stream.hint(`Run ${chalk.blue('sam watch')} to see the logs`)
    } catch (error) {
        cli.stream.error(error)
    }

    ssh.disconnect()
    process.exit()
}
